#!/usr/bin/env python3
# recorder.py - PiStreamer with FFmpeg (HLS + File Recording)
import os
import time
import signal
from datetime import datetime
from pathlib import Path
import sys
import subprocess
import re

sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from flask import Flask, Response
from firmware.hal.usb_manager import USBManager    
from firmware.hal.gpio_leds import gpioLed
from firmware.hal.gnss import GNSSModule
from firmware.hal.rtc import rtcModule
from firmware.hal.micro import Micro
from firmware.config.config_loader import load

class PiStreamer:
    def __init__(self,
                 video_dev=0,  # Index for OpenCV
                 audio_dev="hw:1,0",
                 output_dir="/media/ssd",
                 hls_dir="/tmp/picam_hls",  # HLS output directory
                 segment_seconds=30,  # Short for test
                 led_pin=26):
        self.video_dev = video_dev
        self.audio_dev = audio_dev
        self.output_dir = output_dir
        self.hls_dir = hls_dir
        self.segment_seconds = segment_seconds
        
        # T·∫°o HLS directory n·∫øu ch∆∞a c√≥
        Path(self.hls_dir).mkdir(parents=True, exist_ok=True)
        self.config_file = Path(__file__).parent.parent / 'config' / 'device_full.yaml'
        self.config = load(self.config_file)
        self.led_control = gpioLed(self.config['gpio'].get('record_led', 26))
        self.led_thread = None
        self.led_running = False
        
        # Init RTC and GNSS
        try:
            self.rtc = rtcModule()
            self.rtc_available = True
            print("‚úÖ RTC module kh·ªüi t·∫°o th√†nh c√¥ng")
        except Exception as e:
            print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ kh·ªüi t·∫°o RTC: {e}")
            self.rtc_available = False

        try:
            if self.config['capabilities'].get('gnss', False):
                self.gnss = GNSSModule()
                self.gnss_available = True
                print("‚úÖ GNSS module kh·ªüi t·∫°o th√†nh c√¥ng")
            else:
                print("‚ÑπÔ∏è GNSS kh√¥ng ƒë∆∞·ª£c b·∫≠t trong c·∫•u h√¨nh")
                self.gnss_available = False
        except Exception as e:
            print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ kh·ªüi t·∫°o GNSS: {e}")
            self.gnss_available = False

        self._stop_flag = False
        self.cap = None
        self.video_writer = None
        self.audio_writer = None
        self.current_segment = None
        self.segment_start = None
        self.audio_frames = []  # Buffer for audio frames
        self.audio_device_index = None
        self.micro = None

        # Flask app for serving HLS stream
        self.app = Flask(__name__)
        self.app.debug = False
        
        # No SocketIO needed for HLS
        self.hls_process = None  # FFmpeg process for HLS streaming

    def check_liscam(self):
        """T√¨m index camera ho·∫°t ƒë·ªông - ƒë∆°n gi·∫£n nh∆∞ Flask example"""
        for cam in range(10):  # Th·ª≠ l√™n ƒë·∫øn /dev/video9
            cap = cv2.VideoCapture(cam)
            if cap.isOpened():
                cap.release()
                print(f"‚úÖ T√¨m th·∫•y camera t·∫°i index {cam}")
                return cam
        print("‚ùå Kh√¥ng t√¨m th·∫•y camera n√†o ho·∫°t ƒë·ªông!")
        return 0  # Fallback

    def initial(self):
        """Kh·ªüi t·∫°o c√°c th√¥ng s·ªë t·ª´ file c·∫•u h√¨nh"""
        try:
            # Kh·ªüi t·∫°o USB Storage Manager
            self.usb_manager = USBManager(
                path=self.config['paths']['record_root'],
                min_free_gb=self.config['storage'].get('min_free_gb', 1.0),
                min_free_percent=self.config['storage'].get('min_free_percent', 10),
                camera_id=self.config['device'].get('id', 'PICAM-DEFAULT')
            )
            
            # Ki·ªÉm tra v√† ƒë·ª£i USB storage
            if not self.usb_manager.is_available():
                print("‚ö†Ô∏è ƒêang ƒë·ª£i USB storage...")
                # B·∫Øt ƒë·∫ßu nh·∫•p nh√°y LED khi kh√¥ng c√≥ USB
                self._start_led_blink()
                self.usb_manager.wait_until_available()
                # D·ª´ng nh·∫•p nh√°y khi ƒë√£ c√≥ USB
                self._stop_led_blink()
            
            # Ki·ªÉm tra dung l∆∞·ª£ng tr·ªëng
            if not self.usb_manager.has_enough_space():
                print("‚ö†Ô∏è Dung l∆∞·ª£ng tr·ªëng kh√¥ng ƒë·ªß, ƒëang d·ªçn d·∫πp...")
                self.usb_manager.cleanup_old_files()
                if not self.usb_manager.has_enough_space():
                    raise Exception("Kh√¥ng ƒë·ªß dung l∆∞·ª£ng tr·ªëng sau khi d·ªçn d·∫πp")
            
            print("‚úÖ USB Storage s·∫µn s√†ng")
            
            # C·∫•u h√¨nh video - s·ª≠ d·ª•ng index thay v√¨ path
            self.video_index = self.check_liscam()  # L∆∞u index int
            self.video_size = self.config['video']['v4l2_format']  # e.g., '640x480'
            self.video_fps = self.config['video']['v4l2_fps']
            width, height = map(int, self.video_size.split('x'))
            self.video_width = width
            self.video_height = height

            # C·∫•u h√¨nh audio n·∫øu ƒë∆∞·ª£c b·∫≠t
            if self.config['capabilities'].get('audio', False):
                self.micro = Micro()
                device_str = self.micro.get_first_available_device()
                
                if device_str:
                    # Parse device string
                    # C√≥ th·ªÉ l√†: "hw:1,0" ho·∫∑c "[1] HD camera: USB Audio (hw:1,0)"
                    self.audio_device_index = None
                    
                    # Case 1: Format "[index] name (hw:x,y)"
                    if device_str.startswith('['):
                        try:
                            parts = device_str.split(']')[0].split('[')
                            if len(parts) > 1:
                                self.audio_device_index = int(parts[1].strip())
                        except:
                            pass
                    
                    # Case 2: Just "hw:x,y" - need to find index by querying PyAudio
                    if self.audio_device_index is None and device_str.startswith('hw:'):
                        # Parse hw:x,y to get card and device numbers
                        try:
                            hw_parts = device_str.replace('hw:', '').split(',')
                            card_num = int(hw_parts[0])
                            
                            # Find PyAudio device index by searching for matching ALSA name
                            import pyaudio
                            p = pyaudio.PyAudio()
                            try:
                                for i in range(p.get_device_count()):
                                    info = p.get_device_info_by_index(i)
                                    name = info.get('name', '').lower()
                                    # Check if device name contains "hw:x,y" pattern
                                    if f"hw:{card_num}" in name.lower() or f"card{card_num}" in name.lower():
                                        if info.get('maxInputChannels', 0) > 0:
                                            self.audio_device_index = i
                                            print(f"   ‚Ü≥ T√¨m th·∫•y PyAudio device index: {i} ({info['name']})")
                                            break
                            finally:
                                p.terminate()
                        except Exception as e:
                            print(f"‚ö†Ô∏è L·ªói parse hw string: {e}")
                    
                    self.audio_dev = device_str  # Gi·ªØ config cho log
                    
                    if self.audio_device_index is None:
                        print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ t√¨m PyAudio device index t·ª´: {device_str}")
                        self.audio_device_index = None
                    else:
                        # Ki·ªÉm tra device c√≥ h·ªó tr·ª£ sample rate t·ª´ config kh√¥ng
                        p = pyaudio.PyAudio()
                        try:
                            device_info = p.get_device_info_by_index(self.audio_device_index)
                            print(f"   ‚Ü≥ Device info: {device_info.get('name')}")
                            print(f"   ‚Ü≥ Max input channels: {device_info.get('maxInputChannels')}")
                            print(f"   ‚Ü≥ Default sample rate: {device_info.get('defaultSampleRate')}Hz")
                            
                            # Ki·ªÉm tra s·ªë channels h·ªó tr·ª£
                            max_channels = int(device_info.get('maxInputChannels', 0))
                            if max_channels == 0:
                                print(f"‚ö†Ô∏è Device kh√¥ng h·ªó tr·ª£ input")
                                self.audio_device_index = None
                            else:
                                # Ch·ªçn channels ph√π h·ª£p
                                config_channels = self.config['audio'].get('channels', 1)
                                self.audio_channels = min(config_channels, max_channels)
                                
                                # L·∫•y default sample rate t·ª´ thi·∫øt b·ªã
                                default_rate = int(device_info.get('defaultSampleRate', 44100))
                                
                                # Th·ª≠ default rate tr∆∞·ªõc (th∆∞·ªùng l√† rate device h·ªó tr·ª£ t·ªët nh·∫•t)
                                supported_rates = [default_rate, 44100, 48000, 16000, 22050, 32000, 8000, 11025]
                                # Lo·∫°i b·ªè duplicate
                                supported_rates = list(dict.fromkeys(supported_rates))
                                
                                self.audio_rate = None
                                for rate in supported_rates:
                                    # Th·ª≠ v·ªõi c·∫£ mono v√† stereo
                                    for test_channels in [self.audio_channels, 1, 2]:
                                        if test_channels > max_channels:
                                            continue
                                        try:
                                            # Test v·ªõi input stream
                                            test_stream = p.open(
                                                format=pyaudio.paInt16,
                                                channels=test_channels,
                                                rate=rate,
                                                input=True,
                                                input_device_index=self.audio_device_index,
                                                frames_per_buffer=1024,
                                                start=False
                                            )
                                            test_stream.close()
                                            self.audio_rate = rate
                                            self.audio_channels = test_channels
                                            print(f"   ‚úÖ T√¨m th·∫•y c·∫•u h√¨nh ph√π h·ª£p: {rate}Hz, {test_channels}ch")
                                            break
                                        except Exception as e:
                                            # Debug: in ra l·ªói c·ª• th·ªÉ
                                            if "Invalid sample rate" in str(e):
                                                pass  # Rate kh√¥ng h·ªó tr·ª£, th·ª≠ rate kh√°c
                                            continue
                                    if self.audio_rate is not None:
                                        break
                                
                                if self.audio_rate is None:
                                    print(f"‚ö†Ô∏è Kh√¥ng t√¨m ƒë∆∞·ª£c sample rate ph√π h·ª£p")
                                    print(f"   ‚Ü≥ Th·ª≠ c√°c rate: {supported_rates}")
                                    print(f"   ‚Ü≥ Default rate c·ªßa device: {default_rate}Hz")
                                    self.audio_device_index = None
                        except Exception as e:
                            print(f"‚ö†Ô∏è L·ªói ki·ªÉm tra device: {e}")
                            self.audio_device_index = None
                        finally:
                            p.terminate()
                else:
                    self.audio_device_index = None
                    print("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y thi·∫øt b·ªã audio.")
                
                # Ki·ªÉm tra cu·ªëi c√πng
                if self.audio_device_index is not None and hasattr(self, 'audio_rate'):
                    print(f"   ‚Ü≥ Audio config: {self.audio_channels}ch @ {self.audio_rate}Hz")
                else:
                    self.audio_device_index = None
                    print("   ‚úñÔ∏è Audio: Kh√¥ng th·ªÉ kh·ªüi t·∫°o")
            else:
                self.audio_device_index = None
            
            # C·∫•u h√¨nh l∆∞u tr·ªØ
            self.output_dir = self.config['paths']['record_root']
            self.segment_seconds = self.config['storage']['segment_seconds']
            
            # ƒê·∫£m b·∫£o th∆∞ m·ª•c t·ªìn t·∫°i
            os.makedirs(self.output_dir, exist_ok=True)
            os.makedirs(self.hls_dir, exist_ok=True)
            
            print("‚úÖ ƒê√£ kh·ªüi t·∫°o c·∫•u h√¨nh:")
            print(f"   ‚Ü≥ Video: index {self.video_index} ({self.video_size} @ {self.video_fps}fps)")
            if hasattr(self, 'audio_dev') and self.audio_device_index is not None:
                print(f"   ‚Ü≥ Audio: {self.audio_dev} (index {self.audio_device_index}, {self.audio_channels}ch @ {self.audio_rate}Hz)")
            else:
                print("   ‚úñÔ∏è Audio: Kh√¥ng c√≥ thi·∫øt b·ªã audio")
            print(f"   ‚Ü≥ Storage: {self.output_dir}")
            print(f"   ‚Ü≥ Segment: {self.segment_seconds}s")
            
            # Setup Flask routes (always setup broadcast thread)
            self.setup_flask_routes()
            print("   ‚úÖ Flask routes ƒë√£ ƒë∆∞·ª£c thi·∫øt l·∫≠p")
            return True
            
        except KeyError as e:
            print(f"‚ùå L·ªói c·∫•u h√¨nh: Thi·∫øu th√¥ng s·ªë {e}")
            return False
        except Exception as e:
            print(f"‚ùå L·ªói kh·ªüi t·∫°o: {e}")
            return False

    def _get_rtc_time(self):
        """ƒê·ªçc th·ªùi gian t·ª´ RTC module"""
        try:
            if self.rtc_available:
                rtc_time = self.rtc.read_time()
                return rtc_time.strftime("%Y-%m-%d %H:%M:%S")
            else:
                return datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        except Exception as e:
            # print(f"‚ö†Ô∏è L·ªói ƒë·ªçc RTC: {e}")
            return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    def _get_gps_info(self):
        """ƒê·ªçc th√¥ng tin GPS t·ª´ GNSS module"""
        try:
            if self.gnss_available:
                gps_data = self.gnss.get_location()
                if gps_data and gps_data.get('fix_quality', 0) > 0:
                    lat = gps_data.get('latitude', 0)
                    lon = gps_data.get('longitude', 0)
                    speed = gps_data.get('speed', 0)
                    alt = gps_data.get('altitude', 0)
                    sats = gps_data.get('satellites', 0)
                    return f"GPS: {lat:.6f}, {lon:.6f} | Alt: {alt:.1f}m | Spd: {speed:.1f}km/h | Sats: {sats}"
                return "GPS: Ch·ªù t√≠n hi·ªáu"
            return None
        except Exception as e:
            print(f"‚ö†Ô∏è L·ªói ƒë·ªçc GPS: {e}")
            return None

    def _get_overlay_text(self):
        """L·∫•y text overlay (thay v√¨ file, d√πng direct cho OpenCV)"""
        timestamp = self._get_rtc_time()
        gps_info = self._get_gps_info() or "GPS: Waiting for signal"
        return f"{timestamp}\n{gps_info}"

    def setup_flask_routes(self):
        """Setup Flask routes for HLS streaming"""
        
        # Only register routes once
        if '/' not in [rule.rule for rule in self.app.url_map.iter_rules()]:
            @self.app.route('/')
            def index():
                return {"status": "PiStreamer running", "hls_url": "/hls/stream.m3u8"}
            
            @self.app.route('/hls/<path:filename>')
            def serve_hls(filename):
                """Serve HLS playlist and segments"""
                from flask import send_from_directory
                return send_from_directory(self.hls_dir, filename)
            
            @self.app.route('/health')
            def health():
                return {
                    "status": "ok",
                    "hls_enabled": self.hls_process is not None and self.hls_process.poll() is None,
                    "recording": not self._stop_flag
                }
    
    def _start_hls_stream(self):
        """Start FFmpeg ƒë·ªÉ ghi file MP4 v√† stream HLS ƒë·ªìng th·ªùi"""
        import subprocess
        
        # Stop existing FFmpeg process
        if self.hls_process and self.hls_process.poll() is None:
            self.hls_process.terminate()
            self.hls_process.wait(timeout=5)
        
        # Clear old HLS files
        for f in Path(self.hls_dir).glob("*.ts"):
            try:
                f.unlink()
            except:
                pass
        for f in Path(self.hls_dir).glob("*.m3u8"):
            try:
                f.unlink()
            except:
                pass
        
        # T·∫°o t√™n file output cho segment hi·ªán t·∫°i
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_file = f"{self.output_dir}/{timestamp}_cam0.mp4"
        
        # Build FFmpeg command
        # Input: Video t·ª´ V4L2
        cmd = [
            'ffmpeg',
            '-f', 'v4l2',
            '-input_format', 'mjpeg',
            '-video_size', f'{self.video_width}x{self.video_height}',
            '-framerate', str(self.video_fps),
            '-i', f'/dev/video{self.video_index}',
        ]
        
        # Input: Audio n·∫øu c√≥
        if self.audio_device_index is not None:
            # T√¨m ALSA device name t·ª´ PyAudio index
            import pyaudio
            p = pyaudio.PyAudio()
            try:
                device_info = p.get_device_info_by_index(self.audio_device_index)
                device_name = device_info.get('name', '')
                
                # Parse ƒë·ªÉ l·∫•y hw:x,y format
                alsa_device = "hw:1,0"  # Default
                if 'hw:' in device_name.lower():
                    # Extract hw:x,y from name
                    import re
                    match = re.search(r'hw:(\d+),(\d+)', device_name, re.I)
                    if match:
                        alsa_device = f"hw:{match.group(1)},{match.group(2)}"
                
                cmd.extend([
                    '-f', 'alsa',
                    '-channels', str(self.audio_channels),
                    '-sample_rate', str(self.audio_rate),
                    '-i', alsa_device,
                ])
                print(f"   ‚Ü≥ Audio input: {alsa_device} ({self.audio_channels}ch @ {self.audio_rate}Hz)")
            except Exception as e:
                print(f"   ‚ö†Ô∏è Kh√¥ng th·ªÉ th√™m audio input: {e}")
            finally:
                p.terminate()
        
        # Codec settings
        cmd.extend([
            '-c:v', 'libx264',
            '-preset', 'ultrafast',
            '-tune', 'zerolatency',
            '-g', str(self.video_fps * 2),  # Keyframe every 2 seconds
            '-sc_threshold', '0',
            '-b:v', '1000k',
            '-maxrate', '1200k',
            '-bufsize', '2400k',
        ])
        
        # Audio codec (n·∫øu c√≥ audio input)
        if self.audio_device_index is not None:
            cmd.extend([
                '-c:a', 'aac',
                '-b:a', '128k',
            ])
        
        # Output 1: MP4 file (segment length)
        cmd.extend([
            '-f', 'segment',
            '-segment_time', str(self.segment_seconds),
            '-segment_format', 'mp4',
            '-reset_timestamps', '1',
            '-strftime', '1',
            output_file.replace(timestamp, '%Y%m%d_%H%M%S'),
        ])
        
        # Output 2: HLS stream
        cmd.extend([
            '-f', 'hls',
            '-hls_time', '2',
            '-hls_list_size', '10',
            '-hls_flags', 'delete_segments',
            '-hls_segment_filename', f'{self.hls_dir}/segment_%03d.ts',
            f'{self.hls_dir}/stream.m3u8',
        ])
        
        print(f"üé¨ Starting FFmpeg (Record + HLS)...")
        print(f"   ‚Ü≥ Command: {' '.join(cmd)}")
        
        try:
            self.hls_process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                stdin=subprocess.DEVNULL
            )
            print(f"‚úÖ FFmpeg started (PID: {self.hls_process.pid})")
            print(f"   ‚Ü≥ Recording: {self.output_dir}/*.mp4")
            print(f"   ‚Ü≥ HLS Stream: http://localhost:5000/hls/stream.m3u8")
        except Exception as e:
            print(f"‚ùå Failed to start FFmpeg: {e}")
            self.hls_process = None

    def _mux_to_mp4(self):
        """Gh√©p AVI + WAV th√†nh MP4 b·∫±ng ffmpeg_merge_video_audio"""
        if not hasattr(self, 'segment_manager'):
            return
            
        paths = self.segment_manager.get_current_paths()
        video_file = paths['video']
        audio_file = paths['audio']
        mp4_file = paths['output']
        
        if not os.path.exists(video_file):
            print("‚ö†Ô∏è Kh√¥ng c√≥ file video ƒë·ªÉ gh√©p.")
            return

        # ƒê·ª£i file ƒë∆∞·ª£c flush ho√†n to√†n
        time.sleep(0.5)
        
        merge_success = False
        try:
            # S·ª≠ d·ª•ng ffmpeg_merge_video_audio ƒë·ªÉ gh√©p
            if os.path.exists(audio_file):
                # Gh√©p video v√† audio
                ffmpeg_merge_video_audio(
                    video_file,
                    audio_file,
                    mp4_file,
                    video_codec="libx264",
                    audio_codec="aac",
                )
                print(f"‚úÖ Gh√©p th√†nh c√¥ng: {mp4_file} (video AVI + audio WAV)")
            else:
                # Ch·ªâ convert video sang MP4 kh√¥ng c√≥ audio
                ffmpeg_merge_video_audio(
                    video_file,
                    None,
                    mp4_file,
                    video_codec="libx264",
                    audio_codec="aac",
                )
                print(f"‚úÖ Convert th√†nh c√¥ng: {mp4_file} (video only)")
            
            merge_success = True
                
        except Exception as e:
            print(f"‚ö†Ô∏è L·ªói gh√©p MP4: {e}")
            # X√≥a file MP4 l·ªói n·∫øu c√≥
            if os.path.exists(mp4_file):
                try:
                    os.remove(mp4_file)
                    print(f"   ‚Ü≥ ƒê√£ x√≥a file MP4 l·ªói: {mp4_file}")
                except Exception as e2:
                    print(f"‚ö†Ô∏è L·ªói x√≥a file MP4: {e2}")
        
        # LU√îN th·ª≠ x√≥a source files (d√π merge th√†nh c√¥ng hay th·∫•t b·∫°i)
        finally:
            # ƒê·ª£i th√™m ch√∫t ƒë·ªÉ ƒë·∫£m b·∫£o ffmpeg ƒë√£ release file
            time.sleep(0.3)
            
            deleted_files = []
            failed_files = []
            
            # X√≥a video file
            if os.path.exists(video_file):
                try:
                    os.remove(video_file)
                    deleted_files.append(f"video: {os.path.basename(video_file)}")
                except Exception as e:
                    failed_files.append(f"video: {e}")
            
            # X√≥a audio file
            if os.path.exists(audio_file):
                try:
                    os.remove(audio_file)
                    deleted_files.append(f"audio: {os.path.basename(audio_file)}")
                except Exception as e:
                    failed_files.append(f"audio: {e}")
            
            # Report cleanup status
            if deleted_files:
                print(f"   ‚Ü≥ ƒê√£ x√≥a: {', '.join(deleted_files)}")
            if failed_files:
                print(f"   ‚ö†Ô∏è Kh√¥ng x√≥a ƒë∆∞·ª£c: {', '.join(failed_files)}")
            
            # N·∫øu kh√¥ng c√≥ file MP4 sau merge th√†nh c√¥ng, c·∫£nh b√°o
            if merge_success and not os.path.exists(mp4_file):
                print(f"   ‚ö†Ô∏è C·∫£nh b√°o: File MP4 kh√¥ng t·ªìn t·∫°i sau merge!")

    def _audio_thread(self):
        """Thread ƒë·ªçc v√† ghi audio ƒë·ªôc l·∫≠p v·ªõi auto-reconnect"""
        if self.audio_device_index is None:
            print("‚ö†Ô∏è Kh√¥ng c√≥ thi·∫øt b·ªã audio, audio thread kh√¥ng ch·∫°y")
            return

        # C·∫•u h√¨nh t·ª´ device detection
        CHUNK = 1024
        FORMAT = pyaudio.paInt16
        CHANNELS = getattr(self, 'audio_channels', 1)
        RATE = getattr(self, 'audio_rate', 48000)
        
        reconnect_attempts = 0
        max_reconnect = 3
        stream = None
        p = None
        
        def init_audio():
            """Kh·ªüi t·∫°o ho·∫∑c kh·ªüi t·∫°o l·∫°i audio stream - t·ªëi ∆∞u cho Pi5"""
            try:
                new_p = pyaudio.PyAudio()
                
                # Th√™m delay nh·ªè ƒë·ªÉ tr√°nh audio device lock tr√™n Pi5
                time.sleep(0.2)
                
                new_stream = new_p.open(
                    format=FORMAT,
                    channels=CHANNELS,
                    rate=RATE,
                    frames_per_buffer=CHUNK,
                    input=True,
                    input_device_index=self.audio_device_index,
                    start=False  # Kh√¥ng start ngay, start sau
                )
                
                # Start stream sau khi kh·ªüi t·∫°o
                new_stream.start_stream()
                
                # Test ƒë·ªçc m·ªôt chunk ƒë·ªÉ ch·∫Øc ch·∫Øn ho·∫°t ƒë·ªông
                try:
                    test_data = new_stream.read(CHUNK, exception_on_overflow=False)
                    if test_data:
                        print(f"   ‚úÖ Audio test OK: {len(test_data)} bytes")
                        return new_p, new_stream
                except Exception as e:
                    print(f"   ‚ö†Ô∏è Audio test failed: {e}")
                    new_stream.close()
                    new_p.terminate()
                    return None, None
                    
                return new_p, new_stream
            except Exception as e:
                print(f"   ‚ùå L·ªói init audio: {e}")
                if 'new_p' in locals():
                    try:
                        new_p.terminate()
                    except:
                        pass
                return None, None
        
        # Kh·ªüi t·∫°o audio stream l·∫ßn ƒë·∫ßu
        p, stream = init_audio()
        
        if stream is None:
            print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ m·ªü audio stream")
            print("   ‚Ü≥ Audio recording s·∫Ω b·ªã t·∫Øt, ch·ªâ ghi video")
            return
        
        print(f"‚úÖ Kh·ªüi t·∫°o audio stream th√†nh c√¥ng ({RATE}Hz, {CHANNELS} channels)")

        # ƒê·∫£m b·∫£o c√≥ SegmentManager v√† segment ƒë√£ ƒë∆∞·ª£c b·∫Øt ƒë·∫ßu
        if not hasattr(self, 'segment_manager'):
            self.segment_manager = SegmentManager(self.output_dir, self.segment_seconds)
            
        # ƒê·ª£i segment ƒë∆∞·ª£c kh·ªüi t·∫°o b·ªüi video thread
        wait_start = time.time()
        while self.segment_manager.current_segment is None:
            if time.time() - wait_start > 5:  # Timeout sau 5 gi√¢y
                print("‚ö†Ô∏è Timeout ch·ªù video thread kh·ªüi t·∫°o segment")
                return
            time.sleep(0.1)

        # B·∫Øt ƒë·∫ßu ghi audio v√†o segment hi·ªán t·∫°i
        current_segment = self.segment_manager.get_current_paths()['audio']
        current_writer = wave.open(current_segment, 'wb')
        current_writer.setnchannels(CHANNELS)
        current_writer.setsampwidth(p.get_sample_size(FORMAT))  # 16-bit PCM
        current_writer.setframerate(RATE)
        audio_frames = []  # Initialize array to store frames

        while not self._stop_flag:
            # Ki·ªÉm tra stream c√≤n ho·∫°t ƒë·ªông kh√¥ng
            if stream is None or not stream.is_active():
                print("‚ö†Ô∏è Audio stream kh√¥ng kh·∫£ d·ª•ng, th·ª≠ reconnect...")
                
                # ƒê√≥ng stream hi·ªán t·∫°i
                try:
                    if stream:
                        stream.stop_stream()
                        stream.close()
                    if p:
                        p.terminate()
                    time.sleep(1)
                except:
                    pass
                
                # Th·ª≠ reconnect
                reconnect_attempts += 1
                if reconnect_attempts > max_reconnect:
                    print(f"‚ùå ƒê√£ th·ª≠ reconnect audio {max_reconnect} l·∫ßn th·∫•t b·∫°i, d·ª´ng audio thread")
                    break
                
                print(f"üîÑ ƒêang reconnect audio... (l·∫ßn {reconnect_attempts}/{max_reconnect})")
                p, stream = init_audio()
                
                if stream is None:
                    print("‚ùå Reconnect audio th·∫•t b·∫°i, th·ª≠ l·∫°i sau 2 gi√¢y...")
                    time.sleep(2)
                    continue
                else:
                    print("‚úÖ Reconnect audio th√†nh c√¥ng!")
                    reconnect_attempts = 0
                    continue
            
            try:
                data = stream.read(CHUNK, exception_on_overflow=False)
                audio_frames.append(data)
                
                # Reset reconnect counter khi ƒë·ªçc th√†nh c√¥ng
                reconnect_attempts = 0
                
                # Ki·ªÉm tra segment m·ªõi
                if self.segment_manager.should_start_new():
                    # Ghi to√†n b·ªô frames v√†o file WAV
                    current_writer.writeframes(b''.join(audio_frames))
                    current_writer.close()
                    self.segment_manager.mark_complete('audio')
                    
                    # ƒê·ª£i video ho√†n th√†nh v√† gh√©p file
                    if self.segment_manager.wait_for_merge(timeout=1.0):
                        self._mux_to_mp4()
                    
                    # B·∫Øt ƒë·∫ßu segment m·ªõi
                    current_segment = self.segment_manager.get_current_paths()['audio']
                    current_writer = wave.open(current_segment, 'wb')
                    current_writer.setnchannels(CHANNELS)
                    current_writer.setsampwidth(p.get_sample_size(FORMAT))
                    current_writer.setframerate(RATE)
                    audio_frames = []  # Reset frame buffer
                    
            except Exception as e:
                # Ki·ªÉm tra l·ªói stream closed
                if "Stream closed" in str(e) or "errno -9988" in str(e).lower():
                    print(f"‚ö†Ô∏è Audio stream b·ªã ƒë√≥ng: {e}")
                    stream = None  # Force reconnect ·ªü l·∫ßn l·∫∑p ti·∫øp theo
                    time.sleep(0.5)
                else:
                    print(f"‚ö†Ô∏è L·ªói ƒë·ªçc audio: {e}")
                    time.sleep(0.1)

        # Ghi n·ªët ph·∫ßn cu·ªëi
        try:
            if audio_frames and current_writer:
                current_writer.writeframes(b''.join(audio_frames))
            if current_writer:
                current_writer.close()
        except Exception as e:
            print(f"‚ö†Ô∏è L·ªói ƒë√≥ng audio writer: {e}")
            
        self.segment_manager.mark_complete('audio')
        
        # Cleanup
        try:
            if stream:
                stream.stop_stream()
                stream.close()
            if p:
                p.terminate()
        except Exception as e:
            print(f"‚ö†Ô∏è L·ªói cleanup audio: {e}")
            
        print("‚úÖ Audio thread stopped.")

    def _video_thread(self):
        """Thread ƒë·ªçc v√† ghi video ƒë·ªôc l·∫≠p v·ªõi auto-reconnect"""
        cap = None
        reconnect_attempts = 0
        max_reconnect = 5
        
        def init_camera():
            """Kh·ªüi t·∫°o ho·∫∑c kh·ªüi t·∫°o l·∫°i camera - t·ªëi ∆∞u cho Pi5"""
            try:
                # Th·ª≠ release camera c≈© tr∆∞·ªõc (Pi5 c·∫ßn cleanup k·ªπ)
                if hasattr(self, 'cap') and self.cap is not None:
                    try:
                        self.cap.release()
                    except:
                        pass
                
                # ƒê·ª£i driver reset
                time.sleep(0.5)
                
                # Kh·ªüi t·∫°o camera v·ªõi MMAL backend (t·ªët h∆°n cho Pi5)
                new_cap = cv2.VideoCapture(self.video_index, cv2.CAP_V4L2)
                
                if new_cap.isOpened():
                    # Set resolution
                    new_cap.set(cv2.CAP_PROP_FRAME_WIDTH, self.video_width)
                    new_cap.set(cv2.CAP_PROP_FRAME_HEIGHT, self.video_height)
                    
                    # Gi·∫£m buffer ƒë·ªÉ tr√°nh memory issues tr√™n Pi5
                    new_cap.set(cv2.CAP_PROP_BUFFERSIZE, 1)
                    
                    # Test read m·ªôt frame ƒë·ªÉ ch·∫Øc ch·∫Øn ho·∫°t ƒë·ªông
                    ret, test_frame = new_cap.read()
                    if ret:
                        print(f"   ‚úÖ Camera test OK: {test_frame.shape}")
                        return new_cap
                    else:
                        print("   ‚ö†Ô∏è Camera kh√¥ng ƒë·ªçc ƒë∆∞·ª£c frame test")
                        new_cap.release()
                        return None
                return None
            except Exception as e:
                print(f"   ‚ùå L·ªói init camera: {e}")
                return None
        
        # Kh·ªüi t·∫°o camera l·∫ßn ƒë·∫ßu
        cap = init_camera()
        self.cap = cap  # L∆∞u reference ƒë·ªÉ cleanup sau
        
        if cap is None:
            print("‚ùå Kh√¥ng m·ªü ƒë∆∞·ª£c camera!")
            return
        
        # Kh·ªüi t·∫°o SegmentManager n·∫øu ch∆∞a c√≥
        if not hasattr(self, 'segment_manager'):
            self.segment_manager = SegmentManager(self.output_dir, self.segment_seconds)
            
        # B·∫Øt ƒë·∫ßu segment ƒë·∫ßu ti√™n
        current_segment = self.segment_manager.start_new_segment()
        current_writer = cv2.VideoWriter(
            f"{current_segment}.avi",
            cv2.VideoWriter_fourcc(*'XVID'),
            self.video_fps,
            (self.video_width, self.video_height)
        )

        while not self._stop_flag:
            # Ki·ªÉm tra camera c√≤n ho·∫°t ƒë·ªông kh√¥ng
            if cap is None or not cap.isOpened():
                print("‚ö†Ô∏è Camera kh√¥ng kh·∫£ d·ª•ng, th·ª≠ reconnect...")
                print(f"   ‚Ü≥ cap={cap}, isOpened={cap.isOpened() if cap else 'N/A'}")
                
                # ƒê√≥ng camera hi·ªán t·∫°i n·∫øu c√≥
                try:
                    if cap is not None:
                        cap.release()
                    time.sleep(1)  # ƒê·ª£i driver reset
                except Exception as e:
                    print(f"   ‚ö†Ô∏è L·ªói release camera c≈©: {e}")
                
                # Th·ª≠ reconnect
                reconnect_attempts += 1
                if reconnect_attempts > max_reconnect:
                    print(f"‚ùå ƒê√£ th·ª≠ reconnect {max_reconnect} l·∫ßn th·∫•t b·∫°i, d·ª´ng video thread")
                    break
                
                print(f"üîÑ ƒêang reconnect camera... (l·∫ßn {reconnect_attempts}/{max_reconnect})")
                cap = init_camera()
                self.cap = cap
                
                if cap is None:
                    print("‚ùå Reconnect th·∫•t b·∫°i, th·ª≠ l·∫°i sau 2 gi√¢y...")
                    time.sleep(2)
                    continue
                else:
                    print("‚úÖ Reconnect camera th√†nh c√¥ng!")
                    reconnect_attempts = 0  # Reset counter khi th√†nh c√¥ng
                    continue
            
            # ƒê·ªçc frame v·ªõi timeout protection (Pi5 c√≥ th·ªÉ hang ·ªü ƒë√¢y)
            try:
                ret, frame = cap.read()
                if not ret or frame is None:
                    print(f"‚ö†Ô∏è Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c frame (cap.isOpened={cap.isOpened() if cap else 'None'})")
                    # Kh√¥ng ngay l·∫≠p t·ª©c reconnect, c√≥ th·ªÉ ch·ªâ l√† frame skip
                    reconnect_attempts += 1
                    if reconnect_attempts > 3:
                        print("   ‚Ü≥ Qu√° nhi·ªÅu frame l·ªói, s·∫Ω reconnect...")
                        cap = None  # Force reconnect
                    time.sleep(0.1)
                    continue
            except Exception as e:
                print(f"‚ö†Ô∏è Exception khi ƒë·ªçc frame: {e}")
                cap = None  # Force reconnect
                time.sleep(0.5)
                continue

            # Reset reconnect counter khi ƒë·ªçc frame th√†nh c√¥ng
            reconnect_attempts = 0

            # Add overlay text direct (ch·ªâ m·ªói 2 gi√¢y thay v√¨ m·ªói frame)
            current_time = time.time()
            if not hasattr(self, '_last_overlay_update'):
                self._last_overlay_update = 0
            
            if current_time - self._last_overlay_update >= 1.0:
                self._overlay_text_cached = self._get_overlay_text()
                self._last_overlay_update = current_time
            
            # D√πng cached text
            if hasattr(self, '_overlay_text_cached'):
                overlay_text = self._overlay_text_cached
                lines = overlay_text.split('\n')
                y_offset = 10
                for line in lines:
                    cv2.putText(frame, line, (10, y_offset), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)
                    y_offset += 25

            # Write video frame (ki·ªÉm tra writer tr∆∞·ªõc - CRITICAL cho segment transition)
            try:
                if current_writer is not None and current_writer.isOpened():
                    current_writer.write(frame)
                elif current_writer is None:
                    # Writer ƒëang trong qu√° tr√¨nh transition, skip frame n√†y
                    pass
                else:
                    print("‚ö†Ô∏è VideoWriter kh√¥ng m·ªü ƒë∆∞·ª£c, b·ªè qua frame")
            except Exception as e:
                print(f"‚ö†Ô∏è L·ªói ghi frame: {e}")

            # Check if need new segment
            if self.segment_manager.should_start_new():
                segment_time = time.time() - self.segment_manager.segment_start
                print(f"üîÑ B·∫Øt ƒë·∫ßu segment m·ªõi (segment v·ª´a k·∫øt th√∫c: {segment_time:.1f}s)...")
                
                # 1. STOP writing frames temporarily
                old_writer = current_writer
                current_writer = None  # Ng·ª´ng ghi frame t·∫°m th·ªùi
                print(f"   ‚Ü≥ Stopped frame writing temporarily")
                
                # 2. Release old writer v√† ƒë·ª£i file flush
                try:
                    if old_writer and old_writer.isOpened():
                        old_writer.release()
                        print("   ‚úÖ ƒê√£ release video writer")
                    time.sleep(1.0)  # ƒê·ª£i OS flush file ra disk (Pi c·∫ßn nhi·ªÅu th·ªùi gian)
                except Exception as e:
                    print(f"   ‚ö†Ô∏è L·ªói release writer: {e}")
                
                # 3. Mark video complete
                self.segment_manager.mark_complete('video')
                
                # 4. ƒê·ª£i audio ho√†n th√†nh v√† gh√©p file (trong thread ri√™ng ƒë·ªÉ kh√¥ng block)
                merge_thread = threading.Thread(target=lambda: (
                    self.segment_manager.wait_for_merge(timeout=3.0) and self._mux_to_mp4()
                ), daemon=True)
                merge_thread.start()
                
                # 5. T·∫°o segment m·ªõi NGAY (kh√¥ng ƒë·ª£i merge)
                current_segment = self.segment_manager.start_new_segment()
                print(f"   ‚Ü≥ Segment m·ªõi: {os.path.basename(current_segment)}")
                
                # 6. Kh·ªüi t·∫°o writer m·ªõi TR∆Ø·ªöC KHI ti·∫øp t·ª•c ghi
                try:
                    new_writer = cv2.VideoWriter(
                        f"{current_segment}.avi",
                        cv2.VideoWriter_fourcc(*'XVID'),
                        self.video_fps,
                        (self.video_width, self.video_height)
                    )
                    
                    if not new_writer.isOpened():
                        print("   ‚ö†Ô∏è Kh√¥ng th·ªÉ m·ªü VideoWriter m·ªõi! Th·ª≠ l·∫°i...")
                        time.sleep(0.5)
                        new_writer = cv2.VideoWriter(
                            f"{current_segment}.avi",
                            cv2.VideoWriter_fourcc(*'XVID'),
                            self.video_fps,
                            (self.video_width, self.video_height)
                        )
                        if not new_writer.isOpened():
                            print("   ‚ùå CRITICAL: Kh√¥ng th·ªÉ t·∫°o VideoWriter!")
                            cap = None  # Force reconnect camera
                            continue
                    
                    current_writer = new_writer
                    print("   ‚úÖ VideoWriter m·ªõi ƒë√£ s·∫µn s√†ng")
                        
                except Exception as e:
                    print(f"   ‚ùå L·ªói t·∫°o VideoWriter: {e}")
                    cap = None  # Force reconnect camera
                    continue

            time.sleep(1 / self.video_fps)  # Control FPS

        # Final segment - release v√† flush (v·ªõi protection)
        print("üõë Video thread stopping, releasing resources...")
        try:
            if current_writer and current_writer.isOpened():
                current_writer.release()
                print("   ‚úÖ Released final video writer")
                time.sleep(1.0)  # ƒê·ª£i OS flush file ra disk
            
            self.segment_manager.mark_complete('video')
            
            # Merge final segment trong timeout ng·∫Øn
            if self.segment_manager.wait_for_merge(timeout=3.0):
                self._mux_to_mp4()
        except Exception as e:
            print(f"   ‚ö†Ô∏è L·ªói cleanup video writer: {e}")
        
        # Release camera
        try:
            if cap and cap.isOpened():
                cap.release()
                print("   ‚úÖ Released camera")
        except Exception as e:
            print(f"   ‚ö†Ô∏è L·ªói release camera: {e}")
        
        print("‚úÖ Video thread stopped.")

    def start(self):
        # Check if already running
        if hasattr(self, 'hls_process') and self.hls_process and self.hls_process.poll() is None:
            print("‚ö†Ô∏è FFmpeg ƒëang ch·∫°y!")
            return

        # Ki·ªÉm tra storage
        if hasattr(self, 'usb_manager'):
            if not self.usb_manager.is_available():
                print("‚ö†Ô∏è USB storage kh√¥ng kh·∫£ d·ª•ng!")
                self.led_control.blink(0.5)
                return
            if not self.usb_manager.has_enough_space():
                print("‚ö†Ô∏è Kh√¥ng ƒë·ªß dung l∆∞·ª£ng tr·ªëng!")
                return

        self._stop_flag = False
        print(f"üöÄ B·∫Øt ƒë·∫ßu ghi video + HLS stream...")
        print(f"   ‚Ü≥ Segment: {self.segment_seconds}s")
        print(f"   ‚Ü≥ Output: {self.output_dir}")
        
        # Start FFmpeg (ghi file + HLS stream c√πng l√∫c)
        self._start_hls_stream()
        
        # B·∫≠t LED khi b·∫Øt ƒë·∫ßu
        self.led_control.on()
        print("‚úÖ FFmpeg recording + streaming started")
        
    def is_running(self):
        """Check if FFmpeg is running"""
        return hasattr(self, 'hls_process') and self.hls_process and self.hls_process.poll() is None

    def _led_blink(self):
        """H√†m ƒëi·ªÅu khi·ªÉn LED nh·∫•p nh√°y"""
        while self.led_running:
            self.led_control.on()
            time.sleep(0.5)
            self.led_control.off()
            time.sleep(0.5)

    def _start_led_blink(self):
        """B·∫Øt ƒë·∫ßu nh·∫•p nh√°y LED trong thread ri√™ng"""
        self.led_running = True
        self.led_thread = threading.Thread(target=self._led_blink)
        self.led_thread.daemon = True
        self.led_thread.start()

    def _stop_led_blink(self):
        """D·ª´ng nh·∫•p nh√°y LED"""
        self.led_running = False
        if self.led_thread:
            self.led_thread.join(timeout=1)
        self.led_control.off()

    def stop(self):
        """Stop FFmpeg recording"""
        self._stop_flag = True
        
        if hasattr(self, 'hls_process') and self.hls_process:
            print("‚è± ƒêang d·ª´ng FFmpeg...")
            try:
                # Send quit command to FFmpeg (graceful shutdown)
                self.hls_process.terminate()
                self.hls_process.wait(timeout=10)
                print("   ‚úÖ FFmpeg ƒë√£ d·ª´ng")
            except subprocess.TimeoutExpired:
                print("   ‚ö†Ô∏è FFmpeg kh√¥ng ph·∫£n h·ªìi, force kill...")
                self.hls_process.kill()
                self.hls_process.wait()
            except Exception as e:
                print(f"   ‚ö†Ô∏è L·ªói d·ª´ng FFmpeg: {e}")
        
        # T·∫Øt LED
        self.led_control.off()
        print("‚úÖ ƒê√£ d·ª´ng recording")

    def cleanup(self):
        """D·ª´ng an to√†n FFmpeg v√† c√°c module ph·∫ßn c·ª©ng"""
        print("üßπ B·∫Øt ƒë·∫ßu cleanup...")

        # 1Ô∏è‚É£ Set stop flag
        self._stop_flag = True
        time.sleep(0.5)
        
        # 2Ô∏è‚É£ Stop FFmpeg process
        if hasattr(self, 'hls_process') and self.hls_process:
            try:
                print("üé¨ D·ª´ng FFmpeg...")
                self.hls_process.terminate()
                self.hls_process.wait(timeout=10)
                print("   ‚úÖ FFmpeg ƒë√£ d·ª´ng")
            except subprocess.TimeoutExpired:
                print("   ‚ö†Ô∏è Timeout, force killing FFmpeg...")
                self.hls_process.kill()
            except Exception as e:
                print(f"   ‚ö†Ô∏è L·ªói d·ª´ng FFmpeg: {e}")

        # 3Ô∏è‚É£ T·∫Øt LED
        if hasattr(self, 'led_control'):
            try:
                self.led_control.off()
                print("üí° LED ƒë√£ t·∫Øt")
            except Exception as e:
                print(f"‚ö†Ô∏è L·ªói khi t·∫Øt LED: {e}")

        # 4Ô∏è‚É£ ƒê√≥ng GNSS module
        if hasattr(self, 'gnss') and getattr(self, 'gnss_available', False):
            try:
                self.gnss.close()
                print("üì° GNSS module ƒë√£ ƒë√≥ng")
            except Exception as e:
                print(f"‚ö†Ô∏è L·ªói khi ƒë√≥ng GNSS: {e}")

        # 5Ô∏è‚É£ ƒê√≥ng RTC module
        if hasattr(self, 'rtc') and getattr(self, 'rtc_available', False):
            try:
                self.rtc.close()
                print("‚è∞ RTC module ƒë√£ ƒë√≥ng")
            except Exception as e:
                print(f"‚ö†Ô∏è L·ªói khi ƒë√≥ng RTC: {e}")

        print("‚úÖ Cleanup ho√†n t·∫•t")


def signal_handler(signum, frame):
    """X·ª≠ l√Ω t√≠n hi·ªáu ƒë·ªÉ tho√°t an to√†n"""
    print("\nüõë Nh·∫≠n t√≠n hi·ªáu d·ª´ng, ƒëang tho√°t...")
    if 'recorder' in globals():
        recorder.cleanup()
    sys.exit(0)

if __name__ == "__main__":
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    try:
        recorder = PiStreamer()
        if not recorder.initial():
            print("‚ùå Kh·ªüi t·∫°o th·∫•t b·∫°i, ƒëang tho√°t...")
            sys.exit(1)

        recorder.start()  # üîπ Start FFmpeg recording + HLS stream
        print("üì° HLS stream: http://localhost:5000/hls/stream.m3u8")
        
        # Run Flask app (kh√¥ng c·∫ßn SocketIO)
        recorder.app.run(host="0.0.0.0", port=5000, debug=False)

    except KeyboardInterrupt:
        print("\nüõë ƒêang tho√°t...")
        recorder.cleanup()
    except Exception as e:
        print(f"‚ùå L·ªói ch∆∞∆°ng tr√¨nh: {e}")
        sys.exit(1)